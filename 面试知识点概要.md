# 面试知识点概要

## 一 多线程并发

### 1 请介绍下CAS的原理，并举例说明场景（高级）

​	CAS是一种并发场景下的线程安全操作的技术。即"比较替换"（CompareAndSet）.CAS有三个操作数：内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相等的时候，将内存值修改为B。否则什么也不做。

> 假设a=10; 之后a++操作。在并发的状态下假设存在两个线程：线程1和线程2。根据Java内存模型，线程1和线程2保留了变量a的内存快照。因此线程1和线程2的值也为10. 此时线程1启动，线程2挂起。线程1的值为10，和内存值相等，修改内存值为11.此时线程2启动，然后准备自增操作，发现自己的变量快照为10，内存值为11，修改失败。这样就保证了并发操作。

​	上述例子三个步骤：

​	（1）自旋操作

​	（2）修改变量

​	（3）比较替换

  （1）是一个for的循环操作，不断的进行自旋操作。第二步根据逻辑修改变量。（3）才使用到了CompareAndSet方法。那么CompareAndSet方法如何保证了这次比较替换是原子性操作呢？

### 2 CompareAndSet如何保证原子操作？（高级）

​	Java不像C语言一样可以直接访问操作系统。但是也提供了后门。JNI即Java Native Interface.在CompareAndSet方法中。看如下的代码：

```java
unsafe.compareAndSwapInt(this,valueOffSet,expect,update);
```

上述代码实现了CompareAnsSet的最核心的实现。unsafe是JNI对象。valueoffset是变量在内存值的偏移量。我们可以认为他是内存值即可。这样对变量的操作是硬件级别的操作。实现有：总线锁、高速缓存等。

### 3 CAS的缺陷

​	（1）自旋操作对CPU性能消耗较大

​	（2）只能对单个变量提供原子操作，对于对个变量或者代码块就不能保证

​	（3）ABA的缺陷

### 4 什么是ABA

​	CAS会带来ABA的问题：

>   如线程1从内存X中取出A，这时候另一个线程2也从内存X中取出A，并且线程2进行了一些操作将内存X中的值变成了B，然后线程2又将内存X中的数据变成A，这时候线程1进行CAS操作发现内存X中仍然是A，然后线程1操作成功。虽然线程1的CAS操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。  所以JAVA中提供了AtomicStampedReference/AtomicMarkableReference来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更

### 5 介绍下AQS的实现原理

​	AQS,抽象队列并发器（AbstractQueuedSynchronizer）.提供了一种阻塞锁和一系列依赖FIFO等待队列的同步框架。而我们自己在实现锁的时候，只需要关注状态值state的释放或者获取即可。

### 6 公平锁和非公平锁的区别

​	1 非公平锁在调用一次lock()方法的时候，首先会尝试一次CAS。如果CAS成功，那么就会获取到锁。

​	2 如果第一次CAS失败，那么会进入到tryAcquire()方法，查看状态值state,如果state=0,那么此时会直接CAS去获取锁。否则和公平锁一样，加入到等待队列。直到被前驱节点唤醒。

## 二 集合容器

#### 1 currentHashMap在1.7和1.8之后的区别是什么

数据结构（和HashMap相同）

当链表的长度大于8的时候，此时链表转换为红黑树（泊松分布----哈希碰撞）

​	1.7 链表+数组

​	1.8 链表+数组+红黑树

#### 2 遍历Map的四种方式

​	1 for循环 map.entrySet

​	2 forech  遍历map.keySe()t以及map.values()

​	3 迭代器 map.entrySet().iterator();

​	4 通过键寻找值 map.keySet()  map.get(key)

#### 3  HashMap如何解决hash碰撞的

​	解决hash碰撞的方式有