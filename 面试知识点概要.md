# 面试知识点概要

## 一 多线程并发

### 1 请介绍下CAS的原理，并举例说明场景（高级）

​	CAS是一种并发场景下的线程安全操作的技术。即"比较替换"（CompareAndSet）.CAS有三个操作数：内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相等的时候，将内存值修改为B。否则什么也不做。

> 假设a=10; 之后a++操作。在并发的状态下假设存在两个线程：线程1和线程2。根据Java内存模型，线程1和线程2保留了变量a的内存快照。因此线程1和线程2的值也为10. 此时线程1启动，线程2挂起。线程1的值为10，和内存值相等，修改内存值为11.此时线程2启动，然后准备自增操作，发现自己的变量快照为10，内存值为11，修改失败。这样就保证了并发操作。

​	上述例子三个步骤：

​	（1）自旋操作

​	（2）修改变量

​	（3）比较替换

  （1）是一个for的循环操作，不断的进行自旋操作。第二步根据逻辑修改变量。（3）才使用到了CompareAndSet方法。那么CompareAndSet方法如何保证了这次比较替换是原子性操作呢？

### 2 CompareAndSet如何保证原子操作？（高级）

​	Java不像C语言一样可以直接访问操作系统。但是也提供了后门。JNI即Java Native Interface.在CompareAndSet方法中。看如下的代码：

```java
unsafe.compareAndSwapInt(this,valueOffSet,expect,update);
```

上述代码实现了CompareAnsSet的最核心的实现。unsafe是JNI对象。valueoffset是变量在内存值的偏移量。我们可以认为他是内存值即可。这样对变量的操作是硬件级别的操作。实现有：总线锁、高速缓存等。

### 3 CAS的缺陷

​	（1）自旋操作对CPU性能消耗较大

​	（2）只能对单个变量提供原子操作，对于对个变量或者代码块就不能保证

​	（3）ABA的缺陷

### 4 什么是ABA

​	CAS会带来ABA的问题：

>   如线程1从内存X中取出A，这时候另一个线程2也从内存X中取出A，并且线程2进行了一些操作将内存X中的值变成了B，然后线程2又将内存X中的数据变成A，这时候线程1进行CAS操作发现内存X中仍然是A，然后线程1操作成功。虽然线程1的CAS操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。  所以JAVA中提供了AtomicStampedReference/AtomicMarkableReference来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更

### 5 介绍下AQS的实现原理